# Тема 11. Итераторы и генераторы
Отчет по Теме #11 выполнил(а):
- Легков Иван Сергеевич
- ПИЭ-21-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + |  |
| Задание 4 | + |  |
| Задание 5 | + |  |
| Задание 6 |  | |
| Задание 7 |  | |
| Задание 8 |  |  |
| Задание 9 |  |  |
| Задание 10 |  |  |

# Лабараторные работы 
   ## Лабараторная работа 1


  ```python
numbers =[0,1,2,3,4,5]
for item in numbers:
    print(item)
```
  ### Результат
  ![1](https://github.com/armuane/laba11/blob/main/1.png?raw=true)

 
## Краткий вывод:
В этой программе происходит итерация по списку numbers с использованием цикла for. На каждой итерации значение элемента списка присваивается переменной item, и затем это значение выводится на экран с помощью функции print. Таким образом, программа просто выводит все элементы списка numbers поочередно.


   ## Лабараторная работа 2


  ```python
class CountDown:
    def __init__(self,start):
        self.count=start+1
    def __iter__(self):
        return self
    def __next__(self):
        self.count-=1
        if self.count<0:
           raise StopIteration
        return  self.count

if __name__ =='__main__':
    counter = CountDown(5)
    for i in counter:
        print(i)

```
  ### Результат
  ![2](https://github.com/armuane/laba11/blob/main/2.png?raw=true)

 
## Краткий вывод:
__init__(self, start): Конструктор класса принимает начальное значение start и устанавливает атрибут count равным start + 1. Это значение будет уменьшаться на каждом шаге итерации.

__iter__(self): Метод __iter__ возвращает сам объект, т.е., экземпляр класса, в качестве итератора.

__next__(self): Метод __next__ уменьшает значение атрибута count на 1 и возвращает его. Если count становится отрицательным, вызывается исключение StopIteration, сигнализируя о завершении итерации.

В блоке if __name__ =='__main__': создается экземпляр класса CountDown с начальным значением 5. Затем выполняется цикл for, в котором на каждой итерации выводится текущее значение счетчика. Когда счетчик достигает 0, итерация завершается.


   ## Лабараторная работа 3


  ```python
a = [i** 2 for i in range(1,5)]

print('a- ',a)
for i in a:
    print(i)

print('iter(a)- ', iter(a))
for i in a:
    print(i)
```
  ### Результат
  ![3](https://github.com/armuane/laba11/blob/main/3.png?raw=true)

 
## Краткий вывод:
a = [i**2 for i in range(1, 5)]: Это генератор списка, который создает список a из квадратов чисел от 1 до 4. Таким образом, a будет равно [1, 4, 9, 16].

print('a- ', a): Выводит содержимое списка a.

for i in a:: В цикле for происходит итерация по элементам списка a, и на каждой итерации значение элемента присваивается переменной i, которая затем выводится на экран.

print('iter(a)- ', iter(a)): Создает итератор для списка a с помощью функции iter(). Итераторы используются для прохода по элементам последовательности.

for i in a:: Второй цикл for снова проходит по элементам списка a, но теперь это происходит с использованием итератора. Но так как итератор уже прошел по всем элементам в предыдущем цикле, здесь не произойдет новых итераций, и цикл будет пустым.


   ## Лабараторная работа 4


  ```python
b = (i**2 for i in range(1,5))
print(b)
print('first')
for i in b:
    print(i)
print('second')

for i in b:
    print(i)

```
  ### Результат
  ![4](https://github.com/armuane/laba11/blob/main/4.png?raw=true)

 
## Краткий вывод:

b = (i**2 for i in range(1, 5)): Создается генераторное выражение, которое генерирует квадраты чисел от 1 до 4. Генераторы предоставляют значения по требованию и не сохраняют их в памяти как списки. Переменная b становится генератором.

print(b): Выводит объект-генератор. Генераторы не печатают свои элементы напрямую, поэтому вы увидите информацию о генераторе.

print('first'): Просто выводит строку 'first' для разделения вывода.

for i in b:: В первом цикле for происходит итерация по элементам генератора b, и на каждой итерации значение элемента выводится на экран. Генератор выдаст значения от 1 до 16.

print('second'): Выводит строку 'second' для разделения вывода.

for i in b:: Второй цикл for также пытается итерироваться по элементам генератора b. Однако, так как генераторы предоставляют значения по требованию и не сохраняют предыдущие значения, этот второй цикл начнет итерацию с начала генератора. Таким образом, он также выведет значения от 1 до 16.

   ## Лабараторная работа 5


  ```python
def countdown(count):
    while count>=0:
        yield count
        count-= 1

if __name__ == '__main__':
    counter = countdown(5)
    for i in counter:
        print(i)
        
```
  ### Результат
  ![5](https://github.com/armuane/laba11/blob/main/5.png?raw=true)

 
## Краткий вывод:
def countdown(count):: Определяется функция countdown с параметром count, который является начальным значением счетчика.

while count >= 0:: Запускается цикл while, который будет выполняться, пока count не станет отрицательным.

yield count: С использованием оператора yield функция возвращает текущее значение count и приостанавливает свое выполнение. Это превращает функцию в генератор, который может быть использован для итерации.

count -= 1: Уменьшает значение count на 1 перед следующей итерацией цикла.

if __name__ == '__main__':: Этот блок выполняется только в том случае, если скрипт запускается непосредственно, а не импортируется как модуль.

counter = countdown(5): Создается объект-генератор counter, вызывая функцию countdown с начальным значением 5.

for i in counter:: В цикле for происходит итерация по значениям, которые генерирует генератор counter.

print(i): Каждое значение i выводится на экран. В данном случае, это будет последовательность чисел от 5 до 0.




# Самостоятельные работы
   ## Самотоятельная работа 1


  ```python
def fib(n):
    a, b = 1, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# Пример использования для вывода первых 200 чисел Фибоначчи
if __name__ == '__main__':
    fibonacci_sequence = list(fib(200))
    print(fibonacci_sequence)
```
  ### Результат
  ![6](https://github.com/armuane/laba11/blob/main/6.png?raw=true)

 
## Краткий вывод:
Этот код определяет функцию fib, которая использует итератор и оператор yield для генерации чисел Фибоначчи. Затем в блоке if __name__ == '__main__': создается список из первых 200 чисел Фибоначчи и выводится в консоль.
  ## Самотоятельная работа 2


  ```python
def fib(n):
    a, b = 1, 1
    with open("fib.txt", "w") as file:
        for _ in range(n):
            file.write(str(a) + '\n')
            yield a
            a, b = b, a + b


if __name__ == '__main__':
    fibonacci_sequence = list(fib(200))
    print(fibonacci_sequence)

```
  ### Результат
  ![7](https://github.com/armuane/laba11/blob/main/7.png?raw=true)


 
## Краткий вывод:
После выполнения этого кода, в файле "fib.txt" будут записаны все числа Фибоначчи, каждое на отдельной строке.
# Общий вывод:
Итераторы и генераторы представляют мощные концепции в Python, позволяющие эффективно обрабатывать и создавать последовательности данных. Вот общие выводы по этим темам:

Итераторы:

Итераторы представляют собой объекты, которые могут быть итерируемыми, то есть можно поочередно получать их элементы.
Итераторы реализуют методы __iter__ и __next__, что позволяет им работать в циклах for и использоваться с функцией next().
Генераторы:

Генераторы - это специальный тип итераторов, создаваемых с использованием функций и ключевого слова yield.
Генераторы позволяют генерировать значения на лету, не храня всю последовательность в памяти, что делает их эффективными для работы с большими объемами данных.
Преимущества использования итераторов и генераторов:

Экономия памяти: Генераторы позволяют генерировать значения по мере необходимости, что особенно полезно при работе с большими данными.
Читаемость кода: Итераторы и генераторы могут сделать код более читаемым, особенно при обработке последовательностей данных.
Использование в циклах:

Итераторы и генераторы часто используются в циклах for для обработки последовательностей.
Запись в файл:

Итераторы могут быть использованы для эффективной записи данных в файлы, особенно когда требуется обработка большого объема информации.
Генераторные выражения:

Генераторные выражения предоставляют краткий синтаксис для создания генераторов, что делает код более компактным.
Итераторы и генераторы являются важными инструментами в арсенале Python, позволяя эффективно работать с данными и улучшать производительность программ.
